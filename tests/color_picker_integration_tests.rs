//! Integration tests for the ColorPicker widget
//!
//! These tests verify the ColorPicker widget's behavior and public API
//! from an external perspective, testing the widget as a user of the
//! library would interact with it.

use iced::{Color, Element, Settings};
use iced_aw::ColorPicker;
use iced_test::{Error, Simulator};
use iced_widget::button;
use iced_widget::text::Text;

#[derive(Clone, Debug, PartialEq)]
enum Message {
    Open,
    Cancel,
    Submit(Color),
}

#[test]
fn color_picker_button_can_be_clicked() -> Result<(), Error> {
    use std::cell::RefCell;
    use std::rc::Rc;

    #[derive(Clone)]
    struct StatefulApp {
        clicked: Rc<RefCell<bool>>,
        show_picker: Rc<RefCell<bool>>,
    }

    impl StatefulApp {
        fn new() -> (Self, iced::Task<Message>) {
            (
                StatefulApp {
                    clicked: Rc::new(RefCell::new(false)),
                    show_picker: Rc::new(RefCell::new(false)),
                },
                iced::Task::none(),
            )
        }

        fn update(&mut self, message: Message) {
            match message {
                Message::Open => {
                    *self.clicked.borrow_mut() = true;
                    *self.show_picker.borrow_mut() = true;
                }
                Message::Cancel => {}
                Message::Submit(_) => {}
            }
        }

        fn view(&self) -> Element<'_, Message> {
            let color = Color::from_rgb(0.5, 0.5, 0.5);
            let show_picker = *self.show_picker.borrow();

            ColorPicker::new(
                show_picker,
                color,
                button(Text::new("Click me")).on_press(Message::Open),
                Message::Cancel,
                Message::Submit,
            )
            .into()
        }
    }

    let (mut app, _command) = StatefulApp::new();

    // Initial state - button should be visible
    let mut ui = Simulator::with_settings(Settings::default(), app.view());
    assert!(
        ui.find("Click me").is_ok(),
        "Button should be visible initially"
    );

    // Click the button
    let _ = ui.click("Click me");

    // Process the messages generated by the click
    for message in ui.into_messages() {
        app.update(message);
    }

    // Verify the Open message was received
    assert!(
        *app.clicked.borrow(),
        "Open message should have been received after clicking button"
    );

    Ok(())
}

#[test]
fn color_picker_overlay_cancel_button_interaction() -> Result<(), Error> {
    use std::cell::RefCell;
    use std::rc::Rc;

    #[derive(Clone)]
    struct StatefulApp {
        show_picker: Rc<RefCell<bool>>,
        canceled: Rc<RefCell<bool>>,
    }

    impl StatefulApp {
        fn new() -> (Self, iced::Task<Message>) {
            (
                StatefulApp {
                    show_picker: Rc::new(RefCell::new(false)),
                    canceled: Rc::new(RefCell::new(false)),
                },
                iced::Task::none(),
            )
        }

        fn update(&mut self, message: Message) {
            match message {
                Message::Open => {
                    *self.show_picker.borrow_mut() = true;
                }
                Message::Cancel => {
                    *self.canceled.borrow_mut() = true;
                    *self.show_picker.borrow_mut() = false;
                }
                Message::Submit(_) => {}
            }
        }

        fn view(&self) -> Element<'_, Message> {
            let color = Color::from_rgb(0.5, 0.5, 0.5);
            let show_picker = *self.show_picker.borrow();

            ColorPicker::new(
                show_picker,
                color,
                button(Text::new("Open Picker")).on_press(Message::Open),
                Message::Cancel,
                Message::Submit,
            )
            .into()
        }
    }

    let (mut app, _command) = StatefulApp::new();

    // Click the underlay button to open the picker
    let mut ui = Simulator::with_settings(Settings::default(), app.view());
    let _ = ui.click("Open Picker");

    // Process messages to open the picker
    for message in ui.into_messages() {
        app.update(message);
    }

    // Verify picker is now open
    assert!(
        *app.show_picker.borrow(),
        "Picker should be open after clicking button"
    );

    // Create new UI with the picker open
    let mut ui = Simulator::with_settings(Settings::default(), app.view());

    // Try to find and click the cancel button icon (U+E800)
    let cancel_result = ui.click("\u{e800}");

    // Process any messages
    for message in ui.into_messages() {
        app.update(message);
    }

    // If we successfully clicked the cancel button, verify the state changed
    if cancel_result.is_ok() {
        assert!(
            *app.canceled.borrow(),
            "Cancel should have been called after clicking cancel button"
        );
    }

    Ok(())
}

#[test]
fn color_picker_overlay_submit_button_interaction() -> Result<(), Error> {
    use std::cell::RefCell;
    use std::rc::Rc;

    #[derive(Clone)]
    struct StatefulApp {
        show_picker: Rc<RefCell<bool>>,
        submitted_color: Rc<RefCell<Option<Color>>>,
    }

    impl StatefulApp {
        fn new() -> (Self, iced::Task<Message>) {
            (
                StatefulApp {
                    show_picker: Rc::new(RefCell::new(false)),
                    submitted_color: Rc::new(RefCell::new(None)),
                },
                iced::Task::none(),
            )
        }

        fn update(&mut self, message: Message) {
            match message {
                Message::Open => {
                    *self.show_picker.borrow_mut() = true;
                }
                Message::Cancel => {
                    *self.show_picker.borrow_mut() = false;
                }
                Message::Submit(color) => {
                    *self.submitted_color.borrow_mut() = Some(color);
                    *self.show_picker.borrow_mut() = false;
                }
            }
        }

        fn view(&self) -> Element<'_, Message> {
            let color = Color::from_rgb(0.3, 0.6, 0.9);
            let show_picker = *self.show_picker.borrow();

            ColorPicker::new(
                show_picker,
                color,
                button(Text::new("Open Picker")).on_press(Message::Open),
                Message::Cancel,
                Message::Submit,
            )
            .into()
        }
    }

    let (mut app, _command) = StatefulApp::new();

    // Click the underlay button to open the picker
    let mut ui = Simulator::with_settings(Settings::default(), app.view());
    let _ = ui.click("Open Picker");

    // Process messages to open the picker
    for message in ui.into_messages() {
        app.update(message);
    }

    // Verify picker is now open
    assert!(
        *app.show_picker.borrow(),
        "Picker should be open after clicking button"
    );

    // Create new UI with the picker open
    let mut ui = Simulator::with_settings(Settings::default(), app.view());

    // Try to find and click the submit button icon (U+E802)
    let submit_result = ui.click("\u{e802}");

    // Process any messages
    for message in ui.into_messages() {
        app.update(message);
    }

    // If we successfully clicked the submit button, verify the state changed
    if submit_result.is_ok() {
        assert!(
            app.submitted_color.borrow().is_some(),
            "Submit should have been called with a color"
        );
    }

    Ok(())
}
